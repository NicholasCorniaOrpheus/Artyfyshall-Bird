import abjad
import os
import random

def import_bass_melody():
	bassus_melody_filename = "./campion-1618/bassus_melody.ly"
	bassus_melody_file = open(bassus_melody_filename,'r')
	bassus_melody = bassus_melody_file.read().split(" ")
	for i in range(len(bassus_melody)):
		bassus_melody[i]=abjad.NamedPitch(bassus_melody[i])
	return bassus_melody

def melody2interval(mel):
	# Input abjad.NamedPitch melody list
	#Output abjad.NamedInterval list
	intervals = []
	for i in range(len(mel)-1):
		#returns named interval between pitches
		intervals.append(mel[i]-mel[i+1])
	return intervals


bassus_melody = import_bass_melody()
tenor_melody = []
altus_melody = []
cantus_melody = []
#pitch=abjad.NamedPitch(bassus_melody)
bassus_intervals = melody2interval(bassus_melody)


# Note: insert only the pitch in Lilypond absolute value, without any duration!

#Input first note of the bassus
print("Bass melody imported via bass_melody.ly file")
#pitch=abjad.NamedPitch(input())
#bassus_melody.append(pitch)
print("Insert first note of the tenor:")
pitch=abjad.NamedPitch(input())
tenor_melody.append(pitch)
print("Insert first note of the altus:")
pitch=abjad.NamedPitch(input())
altus_melody.append(pitch)
print("Insert first note of the cantus:")
pitch=abjad.NamedPitch(input())
cantus_melody.append(pitch)

#Add intervals for the bassline:
#exit = 0
#while exit == 0:
	#print("Insert a new interval for the bassus in number of semitones, like -7 for a descending fifth, or using interval name, like +M3 for ascending major third :")
	#bassus_intervals.append(abjad.NamedInterval(input()))
	#bassus_melody.append(bassus_melody[-1]+bassus_intervals[-1])
	#print ("Would you like to exit? yes/no")
	#answer = input()
	#print(bassus_melody)
	#if answer =="yes":
		#exit=1
	#else:
		#exit=0

def simplify_more(p):
	# Improvided version of simplify function in abjad
	#Input abjad.NamedPitch
	# transforms cf ->b and ff -> e

	p = p.simplify()
	# bs to c and bff to a
	if p._get_diatonic_pc_number() == 6:
		if p._get_alteration() == 1:
			p=p._apply_accidental(accidental="flat")
			p=abjad.NamedPitch(p+1)
		if p._get_alteration() == -2:
			p=p._apply_accidental(accidental="sharp")
			p=abjad.NamedPitch(p-1)
	# cf to b and cff to bf
	if p._get_diatonic_pc_number() == 0:
		if p._get_alteration() == -1:
			p=p._apply_accidental(accidental="sharp")
			p=abjad.NamedPitch(p-1)
		if p._get_alteration() == -2:
			p=p._apply_accidental(accidental="sharp")
			p=abjad.NamedPitch(p-1)
	# ff to e and fss to g
	if p._get_diatonic_pc_number() == 3:
		if p._get_alteration() == -1:
			p=p._apply_accidental(accidental="sharp")
			p=abjad.NamedPitch(p-1)
		if p._get_alteration() == 2:
			p=p._apply_accidental(accidental="flat")
			p=abjad.NamedPitch(p+1)
	# gf to fs
	if p._get_diatonic_pc_number() == 4:
		if p._get_alteration() == -1:
			p=p._apply_accidental(accidental="sharp")
			p=abjad.NamedPitch(p-1)
	# eff to d
	if p._get_diatonic_pc_number() == 2:
		if p._get_alteration() == -2:
			p=p._apply_accidental(accidental="sharp")
			p=abjad.NamedPitch(p-1)
	# css to d
	if p._get_diatonic_pc_number() == 0:
		if p._get_alteration() == 2:
			p=p._apply_accidental(accidental="flat")
			p=abjad.NamedPitch(p+1)	
	return p
	

def generate_uppervoice_pitch(bm,interval,direction,um,um_pos):
	#Input: next bass melody
	# Interval for moving uppervoice from if statements
	# Direction = + for up, - for down, x for stable
	# um : uppermelody list
	# um_pos: position to be taken
	#uncertainty major/minor
	#final pitch probability:
	# a - natural notes of the hexachord
	a = 0.6
	a_list = [abjad.NamedPitchClass("c"),abjad.NamedPitchClass("d"),abjad.NamedPitchClass("e"),abjad.NamedPitchClass("f"),abjad.NamedPitchClass("g"),abjad.NamedPitchClass("a")]
	# b - B, Bb, F#
	b = 0.2
	b_list = [abjad.NamedPitchClass("b"),abjad.NamedPitchClass("bf"),abjad.NamedPitchClass("fs")]
	# c - Eb,C# 
	c = 0.15
	c_list = [abjad.NamedPitchClass("ef"),abjad.NamedPitchClass("cs"),abjad.NamedPitchClass("ds")]
	# d - G#, Ab
	d = 0.05
	d_list = [abjad.NamedPitchClass("gs"),abjad.NamedPitchClass("af"),abjad.NamedPitchClass("df"),abjad.NamedPitchClass("gf")]


	if um_pos == 3:
		#stable case
		if direction == "x": 
			um=simplify_more(um)  
			return um
		else:
			# I generate two possible pitches for um, one generated by a major interval, another by a minor
			choice_m = str(direction)+"m"+str(interval)
			choice_M = str(direction)+"M"+str(interval)
			interval_m = abjad.NamedInterval(choice_m)
			interval_M = abjad.NamedInterval(choice_M)
			um_m = um + interval_m
			um_m=simplify_more(um_m)
			um_M = um + interval_M
			um_M=simplify_more(um_M)
			prob_m = 0
			prob_M = 0
			#Search um_m and um_M in the possible pitches:
			for i in range(len(a_list)):
				if abjad.NamedPitchClass(um_m) == a_list[i]:
					prob_m = a
				if abjad.NamedPitchClass(um_M) == a_list[i]:	
					prob_M = a
			for i in range(len(b_list)):
				if abjad.NamedPitchClass(um_m) == b_list[i]:
					prob_m = b
				if abjad.NamedPitchClass(um_M) == b_list[i]:	
					prob_M = b
			for i in range(len(c_list)):
				if abjad.NamedPitchClass(um_m) == c_list[i]:
					prob_m = c
				if abjad.NamedPitchClass(um_M) == c_list[i]:	
					prob_M = c
			#normalizing the probabilities to two choices:
			z=1/(prob_m+prob_M)
			p_m = z*prob_m
			p_M = z*prob_M
			#print("p_m,pM:",p_m,p_M)
			if p_m < p_M:
				p_min = [p_m,um_m]
				p_max = [p_M,um_M] 
			else:
				p_min = [p_M,um_M]
				p_max = [p_m,um_m]
			random_result = random.uniform(0,1)
			#print("Random result:",random_result)
			if random_result < p_min[0]:
				return p_min[1]
			else:
				return p_max[1]

	#  5 and 8 have to be perfect intervals with the bass
	elif um_pos == 5:
		#stable case
		if direction == "x":
			#apply right accidental
			bm_7 = simplify_more(bm+7)
			if um._get_alteration() == bm_7._get_alteration():
				um=simplify_more(um)   
				return um
			elif um._get_alteration() > bm_7._get_alteration():
				um=um-1
				um=simplify_more(um)   
				return um
			else:
				um=um+1
				um=simplify_more(um)   
				return um
		else: 
			interval_step = abjad.NamedInterval(str(direction)+"m"+str(interval))
			um += interval_step
			um=simplify_more(um)
			if (abjad.NamedPitchClass(bm+7)) == abjad.NamedPitchClass(um):
				return um
			else:
				if direction == "-":
					um=um-1
					um=simplify_more(um)
					return um
				else: 
					um=um+1
					um=simplify_more(um)
					return um
				
	# interval 8 casus
	elif um_pos == 8:
		#stable case
		if direction == "x":
			#apply right accidental
			if um._get_alteration() == bm._get_alteration():
				um=simplify_more(um)   
				return um
			elif um._get_alteration() > bm._get_alteration():
				um=um-1
				um=simplify_more(um)   
				return um
			else:
				um=um+1
				um=simplify_more(um)   
				return um
		else: 
			interval_step = abjad.NamedInterval(str(direction)+"m"+str(interval))
			um += interval_step
			um=simplify_more(um)
			if abjad.NamedPitchClass(bm) == abjad.NamedPitchClass(um):
				return um
			else:
				if direction == "-":
					um=um-1
					um=simplify_more(um)
					return um
				else:
					um=um+1
					um=simplify_more(um)
					return um



def generate_uppervoicemelodies(bm,bi,um):
	
	um_position = [[0] for i in range(len(bm))]
	um_position[0] = abjad.NamedInterval.from_pitch_carriers(bm[0],um[0])
	#Extract the interval class and its relative number
	um_position[0]=abjad.NamedInterval(um_position[0]).interval_class
	um_position[0]=abjad.NamedInterval(um_position[0]).number
	for i in range(len(bm)-1):
		
		#print ("Consonance:",i,um_position[i])
		b_int = abjad.NamedIntervalClass(bi[i]).number
		#print ("Bass interval:",b_int)
		#clockwise conditions
		# ascending 2nd - descending 7th (8,5,3 descend by 2nd,3nd,2rd)
		if (b_int == 2 or b_int == -7 ):
			if um_position[i] == 8:
				um_position[i+1]= 5
				um.append(generate_uppervoice_pitch(bm[i+1],3,"-",um[-1],um_position[i+1]))
			elif um_position[i] == 5:
				um_position[i+1]= 3
				um.append(generate_uppervoice_pitch(bm[i+1],2,"-",um[-1],um_position[i+1]))
			elif um_position[i]== 3:
				um_position[i+1]=8
				um.append(generate_uppervoice_pitch(bm[i+1],2,"-",um[-1],um_position[i+1]))
		#ascending 3rd - descending 6th (8 and 3 stable, 5 descend by 2nd)
		if (b_int == 3 or b_int == -6 ):
			if um_position[i] == 8:
				um_position[i+1]= 5
				um.append(generate_uppervoice_pitch(bm[i+1],2,"-",um[-1],um_position[i+1]))
			elif um_position[i] == 5:
				um_position[i+1]= 3
				um.append(generate_uppervoice_pitch(bm[i+1],1,"x",um[-1],um_position[i+1]))
			else:
				um_position[i+1]=8
				um.append(generate_uppervoice_pitch(bm[i+1],1,"x",um[-1],um_position[i+1]))
		# ascending 4th - descending 5th (8,3 ascend by 2nd, 5 stable)
		if (b_int == 4 or b_int == -5 ):
			if um_position[i] == 8:
				um_position[i+1]= 5
				um.append(generate_uppervoice_pitch(bm[i+1],1,"x",um[-1],um_position[i+1]))
			elif um_position[i] == 5:
				um_position[i+1]= 3
				um.append(generate_uppervoice_pitch(bm[i+1],2,"+",um[-1],um_position[i+1]))
			else:
				um_position[i+1]=8
				um.append(generate_uppervoice_pitch(bm[i+1],2,"+",um[-1],um_position[i+1]))
		#counterclockwise condition
		# descending 2nd - ascending 7th (8,5,3 ascend by 3rd,2nd,2nd)
		if (b_int == -2 or b_int == +7): 
			if um_position[i] == 8:
				um_position[i+1]= 3
				um.append(generate_uppervoice_pitch(bm[i+1],2,"+",um[-1],um_position[i+1]))
			elif um_position[i] == 5:
				um_position[i+1]= 8
				um.append(generate_uppervoice_pitch(bm[i+1],3,"+",um[-1],um_position[i+1]))
			else:
				um_position[i+1]=5
				um.append(generate_uppervoice_pitch(bm[i+1],2,"+",um[-1],um_position[i+1]))
		# descending 3rd - ascending 6th (5 and 3 stable, 8 ascend by 2nd)
		if (b_int == -3 or b_int == +6): 
			if um_position[i] == 8:
				um_position[i+1]= 3
				um.append(generate_uppervoice_pitch(bm[i+1],1,"x",um[-1],um_position[i+1]))
			elif um_position[i] == 5:
				um_position[i+1]= 8
				um.append(generate_uppervoice_pitch(bm[i+1],2,"+",um[-1],um_position[i+1]))
			else:
				um_position[i+1]=5
				um.append(generate_uppervoice_pitch(bm[i+1],1,"x",um[-1],um_position[i+1]))
		# descending 4th - ascending 5th (8,3 descend by 2nd, 5 stable)
		if (b_int == -4 or b_int == +5): 
			if um_position[i] == 8:
				um_position[i+1]= 3
				um.append(generate_uppervoice_pitch(bm[i+1],2,"-",um[-1],um_position[i+1]))
			elif um_position[i] == 5:
				um_position[i+1]= 8
				um.append(generate_uppervoice_pitch(bm[i+1],1,"x",um[-1],um_position[i+1]))
			else:
				um_position[i+1]=5
				um.append(generate_uppervoice_pitch(bm[i+1],2,"-",um[-1],um_position[i+1]))
		
			#stable condition	
		if b_int == 1:
			um_position[i+1]=um_position[i]
			um.append(um[-1])

	return um
			


def abjad_staff_generation(m,nm,key,time,clef):
	# m: melody, nm is a string for name
	notes = [abjad.Note(_, (1,1)) for _ in m]
	voice = abjad.Voice(notes, name=nm)
	staff = abjad.Staff([voice], name=nm)
	first_note = abjad.select.note(voice,0)
	abjad.attach(key,first_note)
	abjad.attach(time,first_note)
	abjad.attach(clef,first_note)
	return staff

def make_scale(tonic, intervals):
    pitches = []
    pitch = abjad.NamedPitch(tonic)
    pitches.append(pitch)
    for interval in intervals:
        pitch = pitch + interval
        pitches.append(pitch)
    return pitches

# KEY and SIGNATURE

key = abjad.KeySignature(abjad.NamedPitchClass("c"), abjad.Mode("major"))
time = abjad.TimeSignature((2,1))

#mode = make_scale("c",intervals)

tenor_melody = generate_uppervoicemelodies(bassus_melody,bassus_intervals,tenor_melody)
altus_melody = generate_uppervoicemelodies(bassus_melody,bassus_intervals,altus_melody)
cantus_melody = generate_uppervoicemelodies(bassus_melody,bassus_intervals,cantus_melody)

bassus_staff = abjad_staff_generation(bassus_melody,"bassus",key,time,abjad.Clef("bass"))
tenor_staff = abjad_staff_generation(tenor_melody,"tenor",key,time,abjad.Clef("treble_8"))
altus_staff = abjad_staff_generation(altus_melody,"altus",key,time,abjad.Clef("treble_8"))
cantus_staff = abjad_staff_generation(cantus_melody,"cantus",key,time,abjad.Clef("treble"))

staff_group = abjad.StaffGroup(
        [cantus_staff,altus_staff,tenor_staff,bassus_staff],
        lilypond_type="ChoirStaff",
        name="Choir",
    )

# Preamble
preamble = r"""


\version "2.22.1"
\language "english"

\include "articulate.ly"

#(set-global-staff-size 19)

\paper {
 top-system-spacing.basic-distance = #10
  system-system-spacing.basic-distance = #20
  last-bottom-spacing.basic-distance = #10
horizontal-shift = #7
top-margin = 1.5 \cm
bottom-margin = 1 \cm
left-margin = 1.8 \cm
right-margin = 1.8 \cm
%#(define fonts
 %   (set-global-fonts
    %#:roman "Humanistic"
%#:sans ""
   % )
  %)

}



\header {
    composer = \markup { "Artyfyshall Byrd" }
    title = \markup { "A new way of making foure parts in counterpoint" }
    subtitle = \markup {"London, 1615"}
    copyright = \markup{ "Orpheus Institute, Resounding Libraries" }
    tagline = \markup {" Whoâ€™s Afraid of the Artyfyshall Byrd?, 2024 "}
}

%\include "oll-core/package.ily"
%\loadPackage lilypond-export

%opts.exporter = #exportMusicXML

"""

layout = r"""

\midi{\tempo 2 = 100}   

\layout {
  \context {
    \Score
    \override StaffGrouper.staff-staff-spacing.padding = #5
    \override StaffGrouper.staff-staff-spacing.basic-distance = #5
    \override StaffGrouper.staffgroup-staff-spacing.basic-distance = #5
\override StaffGrouper.staffgroup-staff-spacing.padding = #5
  \override SpacingSpanner.base-shortest-duration = #(ly:make-moment 1/16)

  }
  \context { \Voice \override NoteHead.style = #'baroque }
   \context {
    \Staff
    \RemoveEmptyStaves
  }
  \context{
    \Voice
    \RemoveEmptyStaves
  }
  \context {      \Dynamics
    \override VerticalAxisGroup.nonstaff-relatedstaff-spacing.basic-distance = #10
    }
  
  %\FileExport #opts
  
}

"""

# ENCODING THE SCORE

block = abjad.Block("score")
block.items.append(abjad.Container([staff_group]))
block.items.append(layout)
#score = abjad.Score([staff_group])
#lilypond_file = abjad.LilyPondFile([preamble,score])
lilypond_file = abjad.LilyPondFile([preamble,block])
abjad.show(lilypond_file, output_directory="./campion-1618/temp/")

#rename the file(s)
source_dir = './campion-1618/temp/'
target_dir = './campion-1618/output/'
	
file_names = os.listdir(source_dir)

bassus_string = ""
bassus_staff_string = str(bassus_staff)[8:-19].split()
for i in range(len(bassus_staff_string)):
	bassus_string+= bassus_staff_string[i]
	if i<(len(bassus_staff_string)-1):
		bassus_string+="-"
	
for file_name in file_names:
	# exclude .log files
	if file_name[-3:] =='.ly':
		os.rename(source_dir+file_name,target_dir+"nw-out-"+str(bassus_string)+".ly")

# TO DO
	# Implement algorithm for voice leading based on bassintervals